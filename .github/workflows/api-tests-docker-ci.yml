name: api-tests-docker-ci

on:
  push:
    branches:
      - '**'
  pull_request:
    branches:
      - main
      - Release
    types:
      - opened
      - synchronize
      - reopened
      - closed
  workflow_dispatch:

env:
  IMAGE_NAME: welcome-to-docker-api-tests
  API_BASE_URL: https://api.practicesoftwaretesting.com

jobs:
  smoke-on-feature-push:
    #explain what is refs/heads/main and refs/heads/Release
     # refs/heads/main and refs/heads/Release are Git references that point to the main and Release branches in the repository, respectively. In this workflow, the smoke-on-feature-push job is configured to run only when a push event occurs on branches that do not match these references. This means that the smoke tests will be triggered for feature branches or any other branches that are not main or Release, allowing for early validation of changes before they are merged into the main codebase. 
     #By excluding pushes to main and Release branches, we can focus on testing new features and changes in isolation without running smoke tests on stable branches where critical issues should already have been addressed.  
    #what does refs/heads/main and refs/heads/Release mean in terms of GitHub events?
     # In terms of GitHub events, refs/heads/main and refs/heads/Release refer to the specific branches that are being monitored for push events. When a push event occurs, GitHub checks the reference of the branch that was pushed to. If the reference matches refs/heads/main or refs/heads/Release, the smoke-on-feature-push job will not run. This allows the workflow to target only feature branches or other non-main branches for running smoke tests, ensuring that critical tests are not executed on stable branches where they may not be necessary.
     # This is a common practice in CI/CD workflows to optimize testing and focus on validating new changes in feature branches before they are merged into the main codebase, where they can potentially impact production stability.
     # By using these Git references, we can control the execution of the smoke tests and ensure that they are run at the appropriate stages of the development process, providing early feedback on the quality of new code changes while maintaining the integrity of the main and Release branches.
     # In summary, refs/heads/main and refs/heads/Release are used to specify which branches should be excluded from triggering the smoke-on-feature-push job, allowing for targeted testing of feature branches and preventing unnecessary test runs on stable branches.
     # The smoke-on-feature-push job will only run for push events that occur on branches that do not match refs/heads/main and refs/heads/Release, ensuring that smoke tests are executed for feature branches while excluding stable branches from unnecessary test runs.
     # This allows for early validation of changes in feature branches without impacting the main and Release branches, where critical issues should already have been addressed. By controlling the execution of smoke tests based on Git references, we can optimize our CI/CD workflow and focus on testing new features effectively while maintaining the stability of our main codebase.
     # In terms of GitHub events, refs/heads/main and refs/heads/Release refer to the specific branches that are being monitored for push events. When a push event occurs, GitHub checks the reference of the branch that was pushed to. If the reference matches refs/heads/main or refs/heads/Release, the smoke-on-feature-push job will not run. This allows the workflow to target only feature branches or other non-main branches for running smoke tests, ensuring that critical tests are not executed on stable branches where they may not be necessary.
     if: github.event_name == 'push' && github.ref != 'refs/heads/main' && github.ref != 'refs/heads/Release'
     runs-on: ubuntu-latest
     timeout-minutes: 15

     steps:
      - name: Checkout
        uses: actions/checkout@v4

        #explain the code below
         # This step checks out the code from the repository so that it can be used in subsequent steps. It uses the actions/checkout@v4 action, which is a standard GitHub Action for checking out code. This allows the workflow to access the codebase and build the Docker image for running the smoke tests.
         # The checkout action will clone the repository and make the code available in the runner's workspace, which is necessary for building the Docker image and running the tests against the API.
        # By checking out the code, we ensure that the latest changes from the feature branch are included in the Docker image, allowing us to test the new code against the API and validate that it does not introduce any critical issues before merging into main or Release branches.
        # This step builds a Docker image for running the smoke tests. It uses the Dockerfile.playwright-api file to create the image and tags it with the current commit SHA.
           # The docker build command is used to create a Docker image based on the instructions defined in the Dockerfile.playwright-api file. The -f flag specifies the Dockerfile to use, and the -t flag tags the image with a name that includes the current commit SHA (github.sha) for versioning purposes.
           # Building the Docker image allows us to create a consistent environment for running the smoke tests, ensuring that all dependencies and configurations are included as defined in the Dockerfile. This helps to avoid issues related to environment differences and ensures that the tests run reliably across different runs of the workflow.
           # By tagging the image with the commit SHA, we can easily identify which version of the code is being tested, which is especially useful for debugging and tracking test results over time.
            # This step runs the smoke tests inside the Docker container. It uses the docker run command to start a container from the image built in the previous step.
           # The --rm flag ensures that the container is removed after the tests complete, preventing leftover containers from consuming resources.
           # The -e flag sets the API_BASE_URL environment variable inside the container, allowing the tests to know which API endpoint to target.
           # Finally, the npm run test:api:smoke command is executed inside the container to run the smoke tests.
      - name: Build Smoke test image
        run: |
          
          docker build \
            -f Dockerfile.playwright-api \
            -t api-tests:${{ github.sha }} \
            .

      - name: Prepare smoke report directory
        run: |
          mkdir -p artifacts/smoke

      - name: Run smoke tests with reports inside container
        run: |
         
          docker run --rm \
            -e API_BASE_URL=${{ env.API_BASE_URL }} \
            -e PLAYWRIGHT_HTML_OUTPUT_DIR=/artifacts/playwright-report \
            -e PLAYWRIGHT_JUNIT_OUTPUT_NAME=/artifacts/results.xml \
            -v ${{ github.workspace }}/artifacts/smoke:/artifacts \
            api-tests:${{ github.sha }} \
            npx playwright test tests/api --grep @smoke --reporter=list,html,junit

      - name: Publish smoke report artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: playwright-smoke-report-feature-push
          path: artifacts/smoke
          retention-days: 14

      - name: Add smoke report summary
        if: always()
        run: |
          {
            echo "## Smoke Test Report Artifact"
            echo "- Artifact: playwright-smoke-report-feature-push"
            echo ""
            echo "Download the artifact from this workflow run to inspect HTML and JUnit reports."
          } >> "$GITHUB_STEP_SUMMARY"

  regression-on-pr-to-release:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        if: github.event_name == 'pull_request' && github.base_ref == 'Release'

      - name: Build regression test image
        if: github.event_name == 'pull_request' && github.base_ref == 'Release'
        run: |
          docker build \
            -f Dockerfile.playwright-api \
            -t api-tests:${{ github.sha }} \
            .

      - name: Prepare regression report directory
        if: github.event_name == 'pull_request' && github.base_ref == 'Release'
        run: |
          mkdir -p artifacts/regression

      - name: Run regression tests inside container
        if: github.event_name == 'pull_request' && github.base_ref == 'Release'
        run: |
          docker run --rm \
            -e API_BASE_URL=${{ env.API_BASE_URL }} \
            -e PLAYWRIGHT_HTML_OUTPUT_DIR=/artifacts/playwright-report \
            -e PLAYWRIGHT_JUNIT_OUTPUT_NAME=/artifacts/results.xml \
            -v ${{ github.workspace }}/artifacts/regression:/artifacts \
            api-tests:${{ github.sha }} \
            npx playwright test tests/api --grep @regression --reporter=list,html,junit

      - name: Publish regression report artifact
        if: always() && github.event_name == 'pull_request' && github.base_ref == 'Release'
        uses: actions/upload-artifact@v4
        with:
          name: playwright-regression-report-pr-to-release
          path: artifacts/regression
          retention-days: 14

      - name: Add regression report summary
        if: always() && github.event_name == 'pull_request' && github.base_ref == 'Release'
        run: |
          {
            echo "## Regression Test Report Artifact"
            echo "- Artifact: playwright-regression-report-pr-to-release"
            echo ""
            echo "Download the artifact from this workflow run to inspect HTML and JUnit reports."
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Mark check as discoverable when not applicable
        if: github.event_name != 'pull_request' || github.base_ref != 'Release'
        run: |
          echo "No-op: regression check only runs for PRs targeting Release."

  smoke-and-regression-on-pr-release-to-main:
    runs-on: ubuntu-latest
    timeout-minutes: 25

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        if: github.event_name == 'pull_request' && github.base_ref == 'main' && github.head_ref == 'Release'

      - name: Build test image for release-main validation
        if: github.event_name == 'pull_request' && github.base_ref == 'main' && github.head_ref == 'Release'
        run: |
          docker build \
            -f Dockerfile.playwright-api \
            -t api-tests:${{ github.sha }} \
            .

      - name: Prepare smoke  report directory
        if: github.event_name == 'pull_request' && github.base_ref == 'main' && github.head_ref == 'Release'
        run: |
          mkdir -p artifacts/smoke
         

      - name: Prepare regression report directory
        if: github.event_name == 'pull_request' && github.base_ref == 'main' && github.head_ref == 'Release'
        run: |
          mkdir -p artifacts/regression

      - name: Run smoke tests with reports
        if: github.event_name == 'pull_request' && github.base_ref == 'main' && github.head_ref == 'Release'
        run: |
          docker run --rm \
            -e API_BASE_URL=${{ env.API_BASE_URL }} \
            -e PLAYWRIGHT_HTML_OUTPUT_DIR=/artifacts/playwright-report \
            -e PLAYWRIGHT_JUNIT_OUTPUT_NAME=/artifacts/results.xml \
            -v ${{ github.workspace }}/artifacts/smoke:/artifacts \
            api-tests:${{ github.sha }} \
            npx playwright test tests/api --grep @smoke --reporter=list,html,junit

      - name: Run regression tests with reports
        if: github.event_name == 'pull_request' && github.base_ref == 'main' && github.head_ref == 'Release'
        run: |
          docker run --rm \
            -e API_BASE_URL=${{ env.API_BASE_URL }} \
            -e PLAYWRIGHT_HTML_OUTPUT_DIR=/artifacts/playwright-report \
            -e PLAYWRIGHT_JUNIT_OUTPUT_NAME=/artifacts/results.xml \
            -v ${{ github.workspace }}/artifacts/regression:/artifacts \
            api-tests:${{ github.sha }} \
            npx playwright test tests/api --grep @regression --reporter=list,html,junit

      - name: Publish smoke report artifact
        if: always() && github.event_name == 'pull_request' && github.base_ref == 'main' && github.head_ref == 'Release'
        uses: actions/upload-artifact@v4
        with:
          name: playwright-smoke-report
          path: artifacts/smoke
          retention-days: 14

      - name: Publish regression report artifact
        if: always() && github.event_name == 'pull_request' && github.base_ref == 'main' && github.head_ref == 'Release'
        uses: actions/upload-artifact@v4
        with:
          name: playwright-regression-report
          path: artifacts/regression
          retention-days: 14

      - name: Add smoke report summary
        if: always() && github.event_name == 'pull_request' && github.base_ref == 'main' && github.head_ref == 'Release'
        run: |
          {
            echo "## Test Report Artifacts"
            echo "- Smoke: playwright-smoke-report"
            echo "- Regression: playwright-regression-report"
            echo ""
            echo "Download artifacts from this workflow run to inspect HTML and JUnit reports."
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Mark check as discoverable when not applicable
        if: github.event_name != 'pull_request' || github.base_ref != 'main' || github.head_ref != 'Release'
        run: |
          echo "No-op: smoke+regression check only runs for PRs from Release to main."

  push-image:
    needs:
      - smoke-and-regression-on-pr-release-to-main
    if: github.event_name == 'pull_request' && github.base_ref == 'main' && github.head_ref == 'Release' && github.event.action == 'closed' && github.event.pull_request.merged == true && needs.smoke-and-regression-on-pr-release-to-main.result == 'success'
    runs-on: ubuntu-latest
    timeout-minutes: 15

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Docker Hub login
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          #Explain the image name and tags below
           # The images field specifies the name of the Docker image to be built and pushed. It uses the DOCKERHUB_USERNAME secret and the IMAGE_NAME environment variable to construct the full image name in the format of "username/imagename".
           # The tags field defines how the image should be tagged when pushed to Docker Hub. In this case, it includes two tags: "latest" (a raw value) and a tag based on the commit SHA (type=sha). This allows for both a stable "latest" tag and a unique tag for each commit, making it easier to track which version of the code is associated with each image.
           #what is the value of env.IMAGE_NAME and how is it set?
           # The value of env.IMAGE_NAME is "welcome-to-docker-api-tests". It is set in the env section at the top of the workflow file, where environment variables are defined. This variable is used to specify the name of the Docker image that will be built and pushed to Docker Hub. By using an environment variable, it allows for easier maintenance and updates to the image name in the future, as it can be changed in one place without needing to modify multiple steps in the workflow.
            # By using the DOCKERHUB_USERNAME secret and the IMAGE_NAME environment variable, we can ensure that the Docker image is correctly named and tagged when pushed to Docker Hub, allowing for better organization and versioning of the images.
          images: ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=latest
            type=sha

      - name: Build and push image
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./Dockerfile.playwright-api
          push: true
          #whats does the tags and labels below do in the context of building and pushing a Docker image?
           # The tags field specifies the tags that will be applied to the Docker image when it is pushed to the registry. In this case, it includes a "latest" tag (a raw value) and a tag based on the commit SHA (type=sha). This allows for both a stable "latest" tag and a unique tag for each commit, making it easier to track which version of the code is associated with each image.
           # The labels field allows you to add metadata to the Docker image in the form of key-value pairs. This can include information such as the version, description, or any other relevant details about the image. In this workflow, it uses the outputs from the docker/metadata-action to automatically generate labels based on the GitHub repository and commit information. This metadata can be useful for organizing and managing Docker images in the registry, as well as providing additional context when inspecting images later on.
           # By using both tags and labels, we can ensure that our Docker images are well-organized, easily identifiable, and contain relevant metadata that can assist with tracking and managing different versions of our application in the Docker registry.
           # In summary, the tags field defines how the image will be tagged when pushed to Docker Hub, while the labels field allows for adding metadata to the image for better organization and management in the registry.
           #what is steps.meta.outputs.tags and steps.meta.outputs.labels?
            # steps.meta.outputs.tags and steps.meta.outputs.labels refer to the outputs generated by the docker/metadata-action step with the id "meta". This action extracts metadata from the GitHub repository and commit information to create tags and labels for the Docker image. The tags output will contain the tags that should be applied to the image (such as "latest" and the commit SHA), while the labels output will contain key-value pairs of metadata that can be added as labels to the Docker image. By referencing these outputs in the build-and-push step, we can ensure that the correct tags and labels are applied to the Docker image when it is built and pushed to Docker Hub.

          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}

          #Need a job to execute Playwright UI tests when PR is merged to main, 
          #but want to keep it separate from the smoke/regression API tests since UI tests are more resource intensive and have different failure characteristics. 
         # This job will build and push the Docker image after successful smoke/regression tests, and then we can have a separate workflow that triggers on new image push to run the Playwright UI tests against that image. 
          #This separation allows us to optimize our CI/CD pipeline by only running the UI tests when we have a new image that has passed API tests, ensuring that we are testing stable versions of the application in the UI tests while still validating new changes with smoke/regression tests in a timely manner.
  execute-ui-tests-on-new-image:
    needs:
      - push-image
      #explain what is being checked in the if condition below
       # The if condition checks that the workflow is triggered by a push event and that the reference of the push event starts with 'refs/tags/'. This means that this job will only run when a new tag is pushed to the repository, which typically indicates a new release or version of the application. By checking for tags, we can ensure that the Playwright UI tests are only executed against stable versions of the application that have been officially released, rather than running UI tests on every commit or pull request, which can be more resource intensive and may not always be necessary.
       # This allows us to optimize our CI/CD pipeline by only running the UI tests when we have a new image that has passed API tests and has been tagged for release, ensuring that we are testing stable versions of the application in the UI tests while still validating new changes with smoke/regression tests in a timely manner.
       #what does refs/tags/ mean in terms of GitHub events?
        # In terms of GitHub events, refs/tags/ refers to the reference for tags in the Git repository. 
        #When a push event occurs, GitHub checks the reference of the push to determine if it is a tag. If the reference starts with refs/tags/, it indicates that a new tag has been pushed to the repository. This is often used to signify a new release or version of the application. By checking for this reference in the if condition, we can ensure that certain jobs or actions are only executed when a new tag is created, allowing us to target specific workflows for release events while excluding regular commits or pull requests from triggering those workflows. 
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')
    runs-on: ubuntu-latest
    timeout-minutes: 30

    steps:
      #which git repo is being checked out in the step below and why?
       # The step below checks out the code from the repository where this workflow is defined. 
       # It uses the actions/checkout@v4 action, which is a standard GitHub Action for checking out code. This allows the workflow to access the codebase and run the Playwright UI tests against the new Docker image that was built and pushed in the previous steps. By checking out the code, we can ensure that we have access to the test scripts and any necessary configuration files needed to execute the UI tests against the new image. This is essential for validating that the new image works correctly with the UI tests before it is used in production or further testing environments.
      - name: Checkout
        uses: actions/checkout@v4

      - name: Run Playwright UI tests against new image
        run: |


          docker pull ${{ secrets.DOCKERHUB_USERNAME }}/${{ env.IMAGE_NAME }}:latest

          #is installing playwright and browsers necessary to run the UI tests in the context of this workflow?
           # Yes, installing Playwright and the necessary browsers is necessary to run the UI tests in the context of this workflow. Playwright is a testing framework that allows you to automate browser interactions for testing web applications. In order to execute the UI tests, we need to have Playwright installed along with the browsers that it supports (such as Chromium, Firefox, and WebKit). This setup ensures that we can run the UI tests against the new Docker image effectively, allowing us to validate that the user interface of the application works correctly with the latest changes before it is deployed to production or further testing environments. By including these installation steps in the workflow, we can ensure that all dependencies are in place for successful execution of the Playwright UI tests.
          #what does -g and --with-deps do in the npm install command for Playwright?
           # The -g flag in the npm install command stands for "global" and it tells npm to install the Playwright package globally on the system, making it available for use in any directory without needing to specify a local path. This is useful for command-line tools like Playwright that you want to be able to run from anywhere.
           # The --with-deps flag in the npx playwright install command tells Playwright to install all necessary browser dependencies for the supported browsers. This ensures that the browsers can run correctly in the environment where the tests are executed. By including this flag, we can avoid issues related to missing dependencies that could cause the UI tests to fail when trying to launch the browsers. This is especially important in CI/CD environments where the testing environment may not have all the required dependencies pre-installed, ensuring that the Playwright tests can run smoothly without manual intervention to set up the environment.
           #which playwright.config.ts configuration will be used when running the Playwright tests in this step?
            # The Playwright tests will use the playwright.config.ts configuration file that is present in the repository that is being checked out in the previous step. When the code is checked out, it includes all the files in the repository, including the playwright.config.ts file. This configuration file contains settings and options for how Playwright should run the tests, such as which browsers to use, test timeouts, and other configurations. By checking out the code from the repository, we ensure that we have access to this configuration file, allowing us to run the Playwright UI tests with the specified settings defined in playwright.config.ts. This ensures that the tests are executed consistently according to the configurations set by the development team.
            # In summary, the Playwright UI tests will use the playwright.config.ts file from the checked-out repository, and installing Playwright with the necessary dependencies is essential for running the UI tests successfully in this workflow.
           npm install -g playwright
          npx playwright install --with-deps


          # Example command to run UI tests, this would need to be replaced with the actual test execution command

          npx playwright test tests/ui --reporter=list,html,junit

          #code to publish UI test reports as artifacts and add summary can be added here similar to the smoke/regression test steps above, depending on how the test results are generated and stored in the workflow.
      - name: Publish UI test report artifact
        if: always() && github.event_name == 'push' && startsWith(github.ref, 'refs/tags/')
        uses: actions/upload-artifact@v4
        with:
          name: playwright-ui-test-report
          path: playwright-report/